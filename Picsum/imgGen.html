<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>Picsum 임의 이미지 생성기</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 20px; }
    fieldset { border: 1px solid #ddd; border-radius: 8px; padding: 12px; }
    label { margin-right: 12px; display: inline-flex; align-items: center; gap: 6px; }
    input[type="number"], input[type="text"] { width: 100px; padding: 4px 6px; }
    #images { display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 12px; margin-top: 16px; }
    .card { border: 1px solid #eee; border-radius: 10px; padding: 10px; }
    .thumb { width: 100%; height: auto; display: block; border-radius: 6px; }
    .row { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
    .actions { display: flex; gap: 8px; margin-top: 8px; }
    button { padding: 8px 12px; border: 1px solid #ccc; background: #fafafa; border-radius: 8px; cursor: pointer; }
    button:disabled { opacity: 0.6; cursor: not-allowed; }
    small.mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; word-break: break-all; }
    .is-disabled { pointer-events: none; opacity: .5; }
    .attribution{
      font-size:12px;
      color:#666;
      opacity:.7;            /* 흐릿하게 */
      margin:4px 0 10px;
    }
    .attribution a{
      color:inherit;
      text-decoration:underline;
      text-underline-offset:2px;
      text-decoration-thickness:.5px;
    }
    .attribution:hover{ opacity:1; }  /* 마우스 올리면 선명하게 */
    @media (prefers-color-scheme: dark){
      .attribution{ color:#aaa; }
    }

  </style>
</head>
<body>
  <div class="attribution" role="note" aria-label="API 출처">
    Images via <a href="https://picsum.photos/" target="_blank" rel="noopener">picsum.photos</a>
  </div>

  <h1>Picsum 임의 이미지 생성기</h1>

  <fieldset>
    <legend>옵션</legend>
    <div class="row">
      <label>가로(px) <input type="number" id="w" value="400" min="1" /></label>
      <label>세로(px) <input type="number" id="h" value="300" min="1" /></label>
      <label>개수 <input type="number" id="count" value="1" min="1" max="30" /></label>
      <label><input type="checkbox" id="grayscale" /> grayscale</label>
      <label>blur <input type="number" id="blur" value="0" min="0" max="10" /></label>
      <label>seed(고정 랜덤) <input type="text" id="seed" placeholder="예: 123" /></label>
    </div>
    <div class="row" style="margin-top:10px">
      <button id="btn-generate">이미지 생성</button>
      <button id="btn-clear" title="결과 비우기">초기화</button>
      <button id="btn-from-list" title="/v2/list에서 뽑기">리스트에서 생성(작가표시)</button>
    </div>
  </fieldset>

  <div id="images" aria-live="polite"></div>

  <script>
    const imagesEl = document.getElementById('images');
    const el = id => document.getElementById(id);
    
    // 랜덤 스트링 배열 생성.
    function rand36(len = 12){
      let s = '';
      while (s.length < len) s += Math.random().toString(36).slice(2);
      return s.slice(0, len);
    }

    // Picsum의 랜덤/시드 기반 이미지 앤드포인트 URL을 한 함수로 생성한다.
    function buildPicsumUrl({ w, h, grayscale, blur, seed, nonce }) {

      // seed 결정
      const finalSeed = 
        (seed && String(seed).trim()) ||
        `${Date.now()}-${rand36(8)}`;

      // /seed/{seed}/{w}/{h} 사용
      const base = `https://picsum.photos/seed/${encodeURIComponent(finalSeed)}/${w}/${h}`;
                      
      // 옵션 쿼리
      const params = new URLSearchParams(); // 이걸로 옵션들을 문자화해 base 뒤에 ?로 붙여 최종 URL을 완성하는 역할을 한다.
      if (grayscale) params.set('grayscale', '');    // ?grayscale
      if (blur > 0) params.set('blur', String(blur)); // ?blur=1..10
      
      const s = params.toString();
      return s ? `${base}?${s}` : base;
    }

    // 특정 이미지 ID를 이용해, 여러 옵션으로 고정된 이미지 결과를 만든다.
    // 정해져 있기 때문에, t와 같은 랜덤 토큰을 붙일 필요 없음.
    function buildFromIdUrl({ id, w, h, grayscale, blur }) {
      // 특정 ID 이미지: https://picsum.photos/id/{id}/{w}/{h}

      // 1. 베이스 경로 구성
      const base = `https://picsum.photos/id/${id}/${w}/${h}`;
      // 2. 옵션 쿼리 파라미터 구성
      const params = new URLSearchParams();
      if (grayscale) params.set('grayscale', '');       
      if (blur > 0) params.set('blur', String(blur));
      // 3. URL 조립
      const s = params.toString();
      return s ? `${base}?${s}` : base;
    }

    // 한 장의 이미지를 카드 형태의 HTML 문자열로 만들어 반환한다.
    // 이걸 renderImages()가 모아서 DOM에 삽입한다.
    // src : <img>에 넣을 최종 이미지 URL.
    // info (object | null): 선택. /v2/list로 가져온 메타데이터를 카드에 표시할 때 사용.
    //    기대 필드 :
    //       - info.author (표시 이름)
    //       - info.author_url (작가 페이지 링크)
    //       - info.download_url (원본 이미지 URL)
    //
    // return => String : 카드 전체를 구성하느 HTML 문자열
    function cardTemplate({ src, info }) {
      // info가 있을 때만 작가/원본 링크를 만든다.
      // target="_blank"로 새 탭에서 열고, 보안상 rel="noopener"를 붙여 탭 간 참조 차단.
      // author_url이 비어 있을 수 있어 || '#'로 안전하게 fallback.
      const authorLine = info ? `<div><small>by <a href="${info.author_url || '#'}" target="_blank" rel="noopener">${info.author}</a></small></div>` : '';
      const origLink   = info ? `<a href="${info.download_url}" target="_blank" rel="noopener">원본 보기</a>` : '';
      
      
      return `
        <div class="card">
          <img class="thumb" src="${src}" alt="Picsum random image" loading="lazy" />
          ${authorLine}
          <div class="actions">
            ${origLink}
            <a class="download-link is-disabled" href="${src}" download>다운로드</a>
            <button class="copy" data-url="${src}">URL 복사</button>
          </div>
          <details style="margin-top:6px">
            <summary>URL</summary>
            <small class="mono">${src}</small>
          </details>
        </div>
      `;
    }

    // 'URL 복사' 버튼을 눌렀을 때, 해당 URL을 클립보드에 복사하고, 잠깐 UI 피드백('복사됨!') 표시
    // 파라미터
    // text : 복사할 문자열 (여기서는 이미지 URL)
    // btn : 누른 버튼의 element. 있으면 텍스트를 잠깐 바꿔 사용자 피드백 제공.
    async function copyToClipboard(text, btn) {
      try {
        await navigator.clipboard.writeText(text);
        if (btn) {
          const prev = btn.textContent;
          btn.textContent = '복사됨!';
          setTimeout(() => (btn.textContent = prev), 900);
        }
      } catch (e) {
        alert('클립보드 복사 실패: ' + e.message);
      }
    }

    imagesEl.addEventListener('load', (e) => {
      const img = e.target;
      if (!img.classList.contains('thumb')) return;
      const card = img.closest('.card');
      const link = card && card.querySelector('a.download-link');
      if (link){
        if (img.currentSrc) link.href = img.currentSrc;
        link.classList.remove('is-disabled');
      }
    }, true);
    
    /** 이미지 카드들이 들어있는 부모 컨테이너(#images)에 클릭 리스너를 1개만 단다.
     * 이유(이벤트 위임): 카드와 버튼은 동적으로 계속 추가되므로, 각 버튼마다 리스너를 붙이는 대신
     * 부모 하나가 모두 처리하게 해서 성능/메모리/코드 단순화를 얻는다.
     * 전파 : 하위 요소에서 클릭이 발생하면 버블링(bubbling) 되어 imagesEl까지 올라온다.
     * 이 리스너는 버블링을 받아 처리한다.
     * 참고 : 기본 옵션은 { capture: false } (버블 단계). 캡처 단계에서 받고 싶다면 세 번째 인자
     * 나 옵션 객체로 바꿀 수 있다.
     */
    imagesEl.addEventListener('click', async (e) => {
      // 다운로드 링크 처리
      const a = e.target.closest('a.download-link');
      if (!a) return;

      e.preventDefault();

      const card = a.closest('.card');
      const img = card && card.querySelector('img.thumb');
      if (!img) return;

      // 로드 완료 보장
      if (!img.complete || img.naturalWidth === 0){
        try { await img.decode?.(); } catch {}
        if (!img.complete || img.naturalWidth === 0) {
          await new Promise((res, rej) => {
            img.addEventListener('load', res, { once: true });
            img.addEventListener('error', () => rej(new Error('이미지 로드 실패')), { once: true });
          });
        }
      }

      const finalUrl = img.currentSrc || img.src;
      // UX 잠금
      const prev = a.textContent;
      a.textContent = '다운로드 준비 중...';
      a.setAttribute('aria-busy', 'true');
      a.style.pointerEvents = 'none';

      try {
        // 같은 파일을 확정적으로 받기 위해 currentSrc를 직접 fetch
        const res = await fetch(finalUrl, { mode: 'cors', cache: 'no-store' });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const blob = await res.blob();
        
        // 파일명 힌트 만들기 (URL에서 id/크기 추출 실패 시 타임스탬프 fallback)
        let filename = `picsum-${Date.now()}.jpg`;
        const m = finalUrl.match(/\/id\/(\d+)\/(\d+)\/(\d+)\.jpg/i);
        if (m) {
          const [, id, w, h] = m;
          filename = `picsum-${id}-${w}x${h}.jpg`;
        }

        // Blob -> Object URL -> 가짜 a클릭으로 저장창 띄우기
        const objURL = URL.createObjectURL(blob);
        const tmp = document.createElement('a');
        tmp.href = objURL;
        tmp.download = filename;
        document.body.appendChild(tmp);
        tmp.click();
        tmp.remove();
        URL.revokeObjectURL(objURL);
      } catch (err) {
        alert('이미지 저장 중 오류 : ' + (err?.message || err));
      } finally {
        // UX 복원
        a.textContent = prev;
        a.removeAttribute('aria-busy');
        a.style.pointerEvents = '';
      }
      // 다운로드 처리 끝.
    });

    imagesEl.addEventListener('click', (e) => {
      // URL 복사 버튼 처리

      // e.target : 실제로 클릭된 가장 안쪽의 요소(예: 버튼 안의 <span>을 눌러도 그 <span>이 target일 수 있음)
      // .closest(selector) : 현재 노드에서 시작해 자신->부모->조상을 올라가며 셀렉터와
      // 가장 가까이 매칭되는 요소를 찾는다. 
      // 버튼 내부의 아이콘/텍스트를 눌러 target이 자식이어도, closest가 버튼을 정확히 찾아준다.
      // => 즉, 그리드 아무곳이나 클릭하든, 복사버튼을 눌렀다면 버튼 요소를 찾아라.
      const copyBtn = e.target.closest('button.copy');       // 클래스 copy를 가진 <button>을 찾음
      if (copyBtn){
        copyToClipboard(copyBtn.dataset.url, copyBtn);
        return;
      }
    });

    function getOptions() {
      const w = Math.max(1, parseInt(el('w').value || '0', 10));   // 가로 결정, 하한 1px, 10진 정수만 파싱.
      const h = Math.max(1, parseInt(el('h').value || '0', 10));   // 세로 결정, 하한 1px, 10진 정수만 파싱.
      const count = Math.min(30, Math.max(1, parseInt(el('count').value || '1', 10))); // 생성 개수, 상한 30개. 하한 1개.
      const grayscale = el('grayscale').checked; // 회색빛 여부
      const blur = Math.min(10, Math.max(0, parseInt(el('blur').value || '0', 10))); // 블러 계수
      const seed = (el('seed').value || '').trim();    // 시드 텍스트, 없으면 빈 문자열
      // 이후 버튼 핸들러들이 이 객체를 받아 URL 생성기에 전달
      return { w, h, count, grayscale, blur, seed };   
    }

    // 이미지 URL들의 배열(urls)을 카드 HTML로 변환해서 결과 그리드(#images) 맨 위(afterbegin)에 한 번에 삽입된다.
    // 필요 시 같은 길이의 infos 배열로 작가,원본 링크 메타를 함께 붙인다.
    // 입력
    // urls : string[] -> 카드로 만들 최종 이미지 URL 목록
    // infos : Array<{ author, author_url, download_url }> -> 각 URL과 같은 index로 매칭되는
    //         메타데이터 목록(선택)
    function renderImages(urls, infos=null) {
      // 각 url u를 동일 인덱스(i)의 info와 묶어 cardTemplate로 카드 HTML 문자열 생성.
      // infos가 없으면 작가/원본 영역 생략.
      // join으로 하나의 큰 HTML 문자열을 만듬
      // 장점 : 여러 번 DOM 조작하지 않고 한 번만 삽입 -> 성능 유리
      const html = urls.map((u, i) => cardTemplate({ src: u, info: infos ? infos[i] : null }))
                       .join('');
      // 삽입 위치 : 결과 그리드 맨 위에 쌓는다. (최근 생성이 항상 상단에 위치)
      // 만약 최신 이미지를 아래로 보내고 싶다면 beforeend로 보내면 된다.
      imagesEl.insertAdjacentHTML('afterbegin', html);
    }

    el('btn-clear').addEventListener('click', () => {
      imagesEl.innerHTML = '';
    });

    // 1) 단순 랜덤/시드 생성 (메타데이터 없음)
    el('btn-generate').addEventListener('click', () => {
      // 현재 입력 상태를 스냅샷으로 읽어온다.
      const { w, h, count, grayscale, blur, seed } = getOptions(); 
      // 이미지 N장을 만들기 위해 길이 count인 배열을 생성
      const urls = Array.from({ length: count }, (_, i) =>
        buildPicsumUrl({ w, h, grayscale, blur, seed, 
          // 고유값: 고해상도 시간 + 인덱스 + 난수
          nonce: `${performance.now().toFixed(3)}-${i}-${Math.random().toString(36).slice(2)}`
         })
      );
      // 만든 URL 배열을 카드 HTML로 바꿔 #images 맨 위(afterbegin)에 삽입
      // lazy 방식으로 설정해서, 로딩은 좀 늦다.
      renderImages(urls);
    });

    // 2) /v2/list에서 id를 뽑아 생성 (작가/원본 링크 포함)
    // '리스트에서 생성' 버튼을 누를 시 이벤트 발생
    el('btn-from-list').addEventListener('click', async () => {  // 콜백을 async로 선언 - 내부에서 await 사용 가능
      const { w, h, count, grayscale, blur } = getOptions();
      // v2/list는 pagination이 있으므로 1~10 중 무작위 페이지를 고른다.
      const page = Math.floor(Math.random() * 10) + 1;
      // 한번에 100개를 요청해서 pool을 크게 확보 -> 이후 count개를 뽑을 때 중복/랜덤성이 충분.
      const listUrl = `https://picsum.photos/v2/list?page=${page}&limit=100`;
      try {
        // 목록 JSON을 받아오기 위해 GET 요청. await로 응답 올 때까지 그 줄에서만 잠깐 대기
        const res = await fetch(listUrl);
        // HTTP 응답 본문을 JSON으로 파싱. 성공시 items는 배열
        const items = await res.json(); // [{id, author, width, height, url, download_url}, ...]
        // items 배열에서 무작위로 count개를 뽑는다.
        const picks = Array.from({ length: count }, () => items[Math.floor(Math.random()*items.length)]);
        // 각 pick의 id로 최종요청 URL을 만든다.
        const urls = picks.map(p => buildFromIdUrl({ id: p.id, w, h, grayscale, blur }));
        // 카드에 표시할 메타데이터를 URL들과 같은 인덱스로 정렬.
        // renderImages에서 카드 템플릿이 이 정보를 이용해 링크/표기를 추가함
        const infos = picks.map(p => ({
          author: p.author,
          author_url: p.url,
          download_url: p.download_url
        }));
        // 
        renderImages(urls, infos);
      } catch (e) {
        alert('목록 가져오기 실패: ' + e.message);
      }
    });
  </script>
</body>
</html>
